---
title: "1. TGI model minimal workflow"
author:
  - Francois Mercier
  - Daniel Sabanés Bové
date: last-modified
editor_options: 
  chunk_output_type: inline
format:
  html:
    code-fold: show
math: true
---

## Note

The purpose of this document is to show a minimal workflow for fitting a TGI model using the `brms` package.

## Setup and load data

{{< include _setup_and_load.qmd >}}

{{< include _load_data.qmd >}}

For simplicity, we will for now just use studies 1 and 3, which are both on Atezolizumab in NSCLC, and we rename the patient IDs:

```{r}
df <- tumor_data |> 
  filter(study %in% c("1", "3")) |> 
  na.omit() |>
  droplevels() |> 
  mutate(id = factor(as.numeric(id)))
```

Here we have `r nlevels(df$id)` patients. It is always a good idea to make a plot of the data. Let's look at the first 20 patients e.g.:

```{r}
df |> 
  filter(as.integer(id) <= 20) |>
  ggplot(aes(x = day, y = sld, group = id)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ id) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme(legend.position = "none")
```

## Generalized Stein-Fojo model

We start from the generalized Stein-Fojo model as shown in the slides:

$$
\mu(t_{ij}) = \mu_{0i} \{\phi_i \exp(-s_i \cdot t_{ij}) + (1 - \phi_i) \exp(g_i \cdot t_{ij}) \}
$$

### Mean

We will make one more tweak here. If the time $t$ is negative, i.e. the treatment has not started yet, then it is reasonable to assume that the tumor cannot shrink yet. That is, we have then $\phi_i = 0$. Therefore, the final model for the mean SLD is:

$$
\mu(t_{ij}) = 
\begin{cases} 
\mu_{0i} \exp(g_i \cdot t_{ij}) & \text{if } t_{ij} < 0 \\
\mu_{0i} \{\phi_i \exp(-s_i \cdot t_{ij}) + (1 - \phi_i) \exp(g_i \cdot t_{ij}) \} & \text{if } t_{ij} \geq 0 
\end{cases}
$$

### Likelihood

For the likelihood given the mean SLD, we will assume a normal distribution with a constant coefficient of variation $\sigma$:

$$
y(t_{ij}) \sim \text{N}(\mu(t_{ij}), (\mu(t_{ij})\sigma)^2)
$$

### Random effects

Next, we define the distributions of the random effects $\mu_{0i}$, $s_i$, $g_i$, and $\phi_i$, $i = 1, \dotsc, n$:

$$
\begin{align*}
\mu_{0i} &\sim \text{LogNormal}(\mu_{0}, \omega_{0}^2) \\
s_i &\sim \text{LogNormal}(\mu_{s}, \omega_{s}^2) \\
g_i &\sim \text{LogNormal}(\mu_{g}, \omega_{g}^2) \\
\phi_i &\sim \text{LogitNormal}(\mu_{\phi}, \omega_{\phi}^2)
\end{align*}
$$

### Priors

Finally, we need to define the priors for the hyperparameters. We do this in a kind of empirical Bayes fashion, i.e. we use the data to inform the priors.

For the prior on the average baseline $\mu_0$ and its standard deviation $\omega_0$, we can use the mean and standard deviation of the baseline SLD:

```{r}
baseline <- df |>
  filter(day <= 0, day > -7) |> 
  group_by(id) |> 
  summarize(mean_sld = mean(sld)) |> 
  pull(mean_sld)
(mean_bl <- round(mean(baseline)))
(sd_bl <- round(sd(baseline)))
```

Therefore we take the priors as log normal priors around the log values as means: 

$$
\begin{align*}
\mu_{0} &\sim \text{LogNormal}(`r round(log(mean_bl))`, 5) \\
\omega_{0} &\sim \text{LogNormal}(`r round(log(sd_bl))`, 1) \\
$$

For the coefficient of variation $\sigma$, we try to use a non-informative prior:

$$
\sigma \sim \text{LogNormal}(\log(0.1), 1)
$$

For the average shrinkage and growth rates, $\mu_s$ and $\mu_g$, we consider that these are per day rates, so should be rather small. 

$$
\begin{align*}
\mu_{s} &\sim \text{LogNormal}(\log(0.001), 1) \\
\mu_{g} &\sim \text{LogNormal}(\log(0.001), 1) 
\end{align*}
$$

For the average shrinkage proportion $\mu_{\phi}$, we center the prior around 0.5, i.e. the logit normal distribution is centered around 0:

$$
\mu_{\phi} \sim \text{LogitNormal}(0, 1)
$$

For the standard deviations, we use:

$$
\begin{align*}
\omega_{s} &\sim \text{LogNormal}(\log(0.1), 1) \\
\omega_{g} &\sim \text{LogNormal}(\log(0.1), 1) \\
\omega_{\phi} &\sim \text{LogNormal}(\log(0.1), 1)
\end{align*}
$$

## Fit model

We can now fit the model using `brms`. The structure is determined by the model formula:

```{r}
formula <- bf(sld ~ eta, nl = TRUE) +
  # Define the mean for the likelihood
  nlf(
    eta ~ 
      step(day > 0) * 
        (mu0 * (phi * exp(-s * day) + (1 - phi) * exp(g * day))) +
      step(day <= 0) * 
        (mu0 * exp(g * day))
  ) +
  # Define the standard deviation as a 
  # coefficient tau times the mean.
  # sigma is modelled on the log scale though, therefore:
  nlf(sigma ~ ltau + log(eta)) +
  lf(ltau ~ 1) +
  # Define nonlinear parameter transformations
  nlf(mu0 ~ exp(lmu0)) +
  nlf(phi ~ inv_logit(tphi)) +
  nlf(s ~ exp(ls)) +
  nlf(g ~ exp(lg)) +
  # Define random effect structure
  lf(lmu0 ~ 1 + (1 | id)) + 
  lf(tphi ~ 1 + (1 | id)) + 
  lf(ls ~ 1 + (1 | id)) +
  lf(lg ~ 1 + (1 | id))

# Define the priors
priors <- c(
  prior(normal(log(34), 1), nlpar = "lmu0"),
  prior(normal(log(0.001), 1), nlpar = "ls"),
  prior(normal(log(0.001), 1), nlpar = "lg"),
  prior(normal(0, 1), nlpar = "tphi"),
  prior(lognormal(log(20), 1), nlpar = "lmu0", class = "sd"),
  prior(lognormal(log(0.1), 1), nlpar = "ls", class = "sd"),
  prior(lognormal(log(0.1), 1), nlpar = "lg", class = "sd"),
  prior(lognormal(log(0.1), 1), nlpar = "tphi", class = "sd"),
  prior(normal(log(0.1), 1), nlpar = "ltau")
)

# Good to check the stan code:
# (This also helps to find the names of the parameters
# for which to define the initial values below)
stancode(formula, prior = priors, data = df, family = gaussian())

# Initial values to avoid problems at the beginning
n_patients <- nlevels(df$id)
inits <- list(
  b_lmu0 = array(log(34)),
  b_ls = array(log(0.001)),
  b_lg = array(log(0.001)),
  b_tphi = array(0),
  sd_1 = array(log(20)),
  sd_2 = array(log(0.1)),
  sd_3 = array(log(0.1)),
  sd_4 = array(log(0.1)),
  b_ltau = array(log(0.1)),
  z_1 = matrix(0, nrow = 1, ncol = n_patients),
  z_2 = matrix(0, nrow = 1, ncol = n_patients),
  z_3 = matrix(0, nrow = 1, ncol = n_patients),
  z_4 = matrix(0, nrow = 1, ncol = n_patients)
)

# Fit the model
fit <- brm(
  formula = formula,
  data = df,
  prior = priors,
  family = gaussian(),
  init = rep(list(inits), CHAINS),
  chains = CHAINS, iter = ITER, warmup = WARMUP, seed = BAYES.SEED,
  control = CONTROL, refresh = REFRESH, thin = THIN,
  backend = "cmdstanr"
)

# Summarize the fit
summary(fit)

# Save the fit
save(fit, file = "fit.RData")

post_df <- as_draws_df(fit)
plot(exp(post_df$b_lmu0_Intercept))
plot(post_df$sd_id__lmu0_Intercept)
plot(post_df$sd_id__lg_Intercept)
plot(post_df$sd_id__ls_Intercept)
plot(post_df$sd_id__tphi_Intercept)
plot(post_df$b_ltau_Intercept)
```

Total execution time: 4306.2 seconds.
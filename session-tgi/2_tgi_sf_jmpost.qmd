---
title: "2. TGI model with `jmpost` (SF)"
author:
  - Daniel Sabanés Bové
  - Francois Mercier
date: last-modified
editor_options: 
  chunk_output_type: inline
format:
  html:
    code-fold: show
math: true
cache: true
---

Let's try to fit the same model now with `jmpost`. We will use the same data as in the previous notebook.

## Setup and load data

{{< include _setup_and_load.qmd >}}

{{< include _load_data.qmd >}}

## Data preparation

We start with the subject level data set.
In this case we want to treat all observations as if they come from a single arm and single study for now. Therefore we insert constant study and arm values here.

```{r}
#| label: subj_df_prep

subj_df <- data.frame(
  id = unique(df$id),
  arm = "arm",
  study = "study"
)
subj_data <- DataSubject(
  data = subj_df,
  subject = "id",
  arm = "arm",
  study = "study"
)
```

Next we prepare the longitudinal data object.

```{r}
#| label: long_df_prep

long_df <- df |>
  select(id, year, sld)
long_data <- DataLongitudinal(
  data = long_df,
  formula = sld ~ year
)
```

Now we can create the `JointData` object:

```{r}
#| label: joint_data_prep

joint_data <- DataJoint(
    subject = subj_data,
    longitudinal = long_data
)
```

## Model specification

The statistical model is specified in the `jmpost` vignette [here](https://genentech.github.io/jmpost/main/articles/statistical-specification.html#stein-fojo-model).

Here we just want to fit the longitudinal data, therefore:

```{r}
#| label: tgi_mod_spec

tgi_mod <- JointModel(
    longitudinal = LongitudinalSteinFojo(
        mu_bsld = prior_normal(log(65), 1),
        mu_ks = prior_normal(log(0.52), 1),
        mu_kg = prior_normal(log(1.04), 1),
        omega_bsld = prior_normal(0, 3),
        omega_ks = prior_normal(0, 3),
        omega_kg = prior_normal(0, 3),
        sigma = prior_normal(0, 3)
    )
)
```

Note that the priors on the standard deviations, `omega_*` and `sigma`, are truncated to the positive domain. So we used here truncated normal priors.

## Fit model

We can now fit the model using `jmpost`. 

```{r}
#| label: fit_model

save_file <- here("session-tgi/jm2.RData")
if (file.exists(save_file)) {
  load(save_file)
} else {
  mcmc_results <- sampleStanModel(
      tgi_mod,
      data = joint_data,
      iter_sampling = ITER,
      iter_warmup = WARMUP,
      chains = CHAINS,
      parallel_chains = CHAINS,
      seed = BAYES.SEED,
      refresh = REFRESH
  )
  save(mcmc_results, file = save_file)
}
```

Let's check the convergence of the population parameters:

```{r}
#| label: check_convergence

vars <- c(
    "lm_sf_mu_bsld",
    "lm_sf_mu_ks",
    "lm_sf_mu_kg",
    "lm_sf_sigma",
    "lm_sf_omega_bsld",
    "lm_sf_omega_ks",
    "lm_sf_omega_kg"
)
mcmc_res_cmdstan <- cmdstanr::as.CmdStanMCMC(mcmc_results)
mcmc_res_cmdstan$summary(vars)
```

This looks good, let's check the traceplots:

```{r}
#| label: plot_trace

vars_draws <- mcmc_res_cmdstan$draws(vars)
mcmc_trace(vars_draws)
```

They also look ok, all chains are mixing well in the same range of parameter values.

## Observation vs. model fit

Let's check the fit of the model to the data:

```{r}
#| label: plot_fit

pt_subset <- as.character(1:20)
fit_subset <- LongitudinalQuantities(
  mcmc_results, 
  grid = GridObserved(subjects = pt_subset)
)

autoplot(fit_subset)+
  labs(x = "Time (years)", y = "SLD (mm)")
```

So this works very nicely.

## Prior vs. posterior

Let's check the prior vs. posterior for the parameters:

```{r}
#| label: plot_prior_post

post_samples <- as_draws_df(vars_draws) |> 
  rename(
    mu_bsld = "lm_sf_mu_bsld[1]",
    mu_ks = "lm_sf_mu_ks[1]",
    mu_kg = "lm_sf_mu_kg[1]",
    omega_bsld = "lm_sf_omega_bsld[1]",
    omega_ks = "lm_sf_omega_ks[1]",
    omega_kg = "lm_sf_omega_kg[1]",
    sigma = lm_sf_sigma
  ) |> 
  mutate(type = "posterior") |> 
  select(mu_bsld, mu_ks, mu_kg, omega_bsld, omega_ks, omega_kg, sigma, type)

n_prior_samples <- nrow(post_samples)
prior_samples <- data.frame(
    mu_bsld = rnorm(n_prior_samples, log(65), 1),
    mu_ks = rnorm(n_prior_samples, log(0.52), 1),
    mu_kg = rnorm(n_prior_samples, log(1.04), 1),
    omega_bsld = rtruncnorm(n_prior_samples, a = 0, mean = 0, sd = 3),
    omega_ks = rtruncnorm(n_prior_samples, a = 0, mean = 0, sd = 3),
    omega_kg = rtruncnorm(n_prior_samples, a = 0, mean = 0, sd = 3),
    sigma = rtruncnorm(n_prior_samples, a = 0, mean = 0, sd = 3)
  ) |> 
  mutate(type = "prior")

# Combine the two
combined_samples <- rbind(post_samples, prior_samples) |> 
  pivot_longer(cols = -type, names_to = "parameter", values_to = "value")

ggplot(combined_samples, aes(x = value, fill = type)) +
  geom_density(alpha = 0.5) +
  facet_wrap(~parameter, scales = "free") +
  theme_minimal()
```

This looks good, because the priors are covering the range of the posterior samples and are not too informative.

## Parameter estimates

Here we need to be careful: We are interested in the posterior mean estimates of the baseline, shrinkage and growth population rates on the original scale. Because we model them on the log scale as normal distributed, we need to use the mean of the log-normal distribution to get the mean on the original scale.

```{r}
#| label: par_estimates

post_sum <- post_samples |>
  mutate(
    b0 = exp(mu_bsld + omega_bsld^2 / 2), 
    ks = exp(mu_ks + omega_ks^2 / 2), 
    kg = exp(mu_kg + omega_kg^2 / 2),
    cv_0 = sqrt(exp(omega_bsld^2) - 1),
    cv_s = sqrt(exp(omega_ks^2) - 1),
    cv_g = sqrt(exp(omega_kg^2) - 1)
  ) |>
  select(b0, ks, kg, omega_bsld, omega_ks, omega_kg, cv_0, cv_s, cv_g, sigma) |>
  summarize_draws() |>
  gt() |>
  fmt_number(n_sigfig = 3)
post_sum
```

We can see that these are consistent with the estimates from the `brms` model earlier.

## Model comparison with LOO

As we have seen for `brms`, also for `jmpost` we can easily compute the LOO criterion:

```{r}
#| label: loo

loo_res <- mcmc_res_cmdstan$loo(r_eff = FALSE)
loo_res
```

Underneath this is using the [$loo()](https://mc-stan.org/cmdstanr/reference/fit-method-loo.html) method from `cmdstanr`. 

## Tipps and tricks

- Also here it is possible to look at the underlying Stan code:
  ```{r}
  #| eval: false

  tmp <- tempfile()
  write_stan(tgi_mod, destination = tmp)
  file.edit(tmp) # opens the Stan file in the default editor
  ```